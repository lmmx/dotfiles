# PDF-related
# ===========

# Argument is the PDF file which will have its first page removed and then get its margins cropped
function pdfuncovercrop () {
	IN_PDF="$@"
	PDF_N_PAGES=$(pdfinfo "$IN_PDF"  | grep "Pages" | sed 's/[^0-9]*//')
	if ! [ "$PDF_N_PAGES" -eq "$PDF_N_PAGES" ] 2> /dev/null
	then
		>&2 echo "Non-integer page number."
		return 1
	fi
	if ! [ "$PDF_N_PAGES" -gt 1 ] 2> /dev/null
	then
		>&2 echo "PDF does not have multiple pages."
		return 2
	fi
	stapler sel "$IN_PDF" 2-"$PDF_N_PAGES" stapler_output.pdf
	STAPLER_EXIT_CODE=$?
	if ! [ $STAPLER_EXIT_CODE -eq 0 ] 2> /dev/null
	then
		>&2 echo "Stapler couldn't discard first page."
		return 3
	fi
	mv stapler_output.pdf "$IN_PDF"
	pdf-crop-margins -v -s "$IN_PDF" -o pcm_output.pdf
	mv pcm_output.pdf "$IN_PDF"
}

# Argument is the PDF file which will have its margins cropped
function pdfcropinplace () {
	IN_PDF="$@"
	pdf-crop-margins -v -s "$IN_PDF" -o pcm_output.pdf
	mv pcm_output.pdf "$IN_PDF"
}


# Add a paper, 2-up
#  arg 1: reading file
# (arg 3-6: trim dimensions for pdfnup)
function addreading() {
	# TODO: if the target filename doesn't match schema format then generate auth16_paper-title.pdf with `read` input
	# crop the PDF and move the original to the originals directory (renamed to auth16_uncropped.pdf)
	pdftrim "$@"
	trim_ret_code=$?
	if [ $trim_ret_code -gt 0 ]; then return $trim_ret_code; fi
	# if directory(file)/originals doesn't exist then make it
	originals_dir="$(dirname $outputpdf)/originals/"
	if [ ! -d "$originals_dir" ]; then
		>&2 echo "Creating a new folder '$originals_dir'"
		mkdir "$originals_dir"
	fi
	base_in=$(basename $inputpdf)
	base_out=$(basename $outputpdf)
	base_out_denup="$(basename $outputpdf -nup.pdf).pdf"
	if [ "$base_in" = "$base_out_denup" ]; then
		# in all likelihood [i.e. by design] this rename destination is just input filename BUT doesn't need be
		# in case you accidentally run pdfnup on an already-trimmed/2-upped file, don't overwrite originals:
		mv $inputpdf --backup=t "$originals_dir/"
		# do overwrite cropped versions (e.g. trying out different settings from the 
		mv $outputpdf $(dirname $outputpdf)/$base_out_denup
	else
		mv $inputpdf --backup=t "$originals_dir/" # the output file has already been renamed, move on
	fi
	return 0
}

# Extending idea: Recrop - match a cropped file to its originals/ copy and then recrop with given trim values
function recropreading() {
	re_pdf=$1
	re_pdf_dir=$(dirname $re_pdf)
	# if a file exists with the same name in the child originals/ folder
	re_pdf_original=$re_pdf_dir/originals/$(basename $re_pdf)
	if [ -z $re_pdf_original ]; then
		>&2 echo "No such original file (or the name has been changed)."
		return 6
	fi
	mv $re_pdf_original $re_pdf
	addreading "$@"
}

# Crop a paper with `pdfnup --trim 'l b r t' input.pdf`
#  arg 1: reading file
# (arg 2: optional output filename)
#  arg 3(-6): trim dimensions for pdfnup - a single number to be used for all dimensions or 4 separate
# Returns 0 exit code if successful, 1-5 if it fails at the numbered error points
function pdftrim() {
	# checking "$2 -eq $2" actually asks
	# if $2 is an integer (i.e. not the output filename) http://stackoverflow.com/a/808740/2668831
	explicit_outfile="1" # switch to make output filename explicit: 0 for false, 1 for true
	if [ $2 -eq $2 ] 2>/dev/null; then
		inputpdf=$1
		if [ $explicit_outfile -eq 1 ]; then
			outputpdf=$(basename "$inputpdf" '.pdf')"-nup.pdf"
		else outputpdf=''
		fi
	elif [ $3 -eq $3 ] 2>/dev/null; then
		inputpdf=$1
		outputpdf=$2
		shift # $1 is dropped, $2 becomes $1 but doesn't matter as stored it
		# now equivalent to test no. of dimension variables as it is when no outfile specified
	else
		>&2 echo 'Please provide trim dimensions (anti-c/w from left) with the filename(s).'
		return 1
	fi
	if [ -z $1 ]; then
		>&2 echo 'Please provide trim dimensions (anti-c/w from left) with the filename(s).'
		return 2
	fi
	if [ -z $2 ]; then
		>&2 echo 'No trim dimensions specified: "<- v -> ^" (anti-c/w from left).'
		return 3
	fi
	# if the array generated by bash parameter expansion of space-separated variable $2 has 4 values
	arg2_as_array=($2)
	if [ ${#arg2_as_array[@]} -eq 4 ] 2>/dev/null; then
		trim_dims=($2) # not double quoting is essential here
	elif [ $# -eq 5 ]; then
		trim_dims=($2 $3 $4 $5)
		if [ ${#trim_dims[@]} -ne 4 ] 2>/dev/null; then
			>&2 echo 'Wrong number of trim dimensions specified? Give them as "<- v -> ^" (anti-c/w from left).'
			return 4
		fi
	elif [ $2 -eq $2 ] 2>/dev/null && [ $# -eq 2 ]; then
		trim_dims=($2 $2 $2 $2)
	else
		>&2 echo 'Wrong number of trim dimensions specified: "<- v -> ^" (anti-c/w from left).'
		return 5
	fi
	trim_param="${trim_dims[0]} ${trim_dims[1]} ${trim_dims[2]} ${trim_dims[3]}"
	if [[ -z $outputpdf ]];
	then pdfnup --trim "$trim_param" $inputpdf
	else pdfnup --trim "$trim_param" $inputpdf -o $outputpdf
	fi
	return 0
}

# Pass in a PDF in a readings folder [or organised subfolder] and open a `touch`'d .md note

# Usage:
#   findnote maddox16_genomics-paper.pdf
# 
# The above will echo to STDOUT the path to its note (not useful on its own)
# For a paper:
#   /path/readings/
# A new note is made if it doesn't exist:
#   /path/notes/maddox16.md
#
# If no notes file is found matching the prefix (e.g. `maddox16`) the user will
# be asked to verify whether to create the new file.
#
# If a second argument is passed in as well as the PDF filename, `--skip-create-check`,
# then markdown file creation will proceed without this verification.
#
#   - Recommendation: use the `--skip-create-check` option when downloading the PDF
#
# To edit the note use takenotes in the same format, which will open editR
#
# TODO: allow passing in author16 to open the notes file (new function `opennote`)
function findnote () {
	FN_STARTDIR=$(readlink -f ./)
	file_auth_prefix=${1%_*}
	if [ -z $file_auth_prefix ]; then
		file_auth_prefix=${1%.pdf}
		>&2 echo "No arguments specified, what am I psychic? Please provide a PDF file."
		cd $FN_STARTDIR
		return 7
	elif [ "$file_auth_prefix" = "$1" ]; then
		# no change i.e. it's not a .pdf extension
		# can't be bothered being lax in coding this
		>&2 echo "Please provide a PDF file ('.pdf' extension not detected)."
		>&2 echo "  [Enter to quit, or space to override and use the file anyway] "
		read -d'' -s -n1 -r
		if [ "$REPLY" = ' ' ]; then
			file_auth_prefix=${1%.*}
			>&2 echo -e "\nFile extension will be ignored."
		else
			>&2 echo -e "\nNote making cancelled (no files have been changed)."
			cd $FN_STARTDIR
			return 8
		fi
	fi
	# A valid PDF file was specified, "$file_auth_prefix.md" is the note filename
	readingfolder=$(readlink -f $(dirname $1))
	cd $readingfolder
	while [ "${PWD##*/}" != 'readings' ]; do
		oldrfwd=$PWD
		cd ..
		if [ $oldrfwd = $PWD ]; then
			# cannot cd upwards any further, break out of the loop
			>&2 echo "Unable to find a 'readings' folder above the specified file."
			notes_dir=$(readlink -f $(dirname $(readlink -f $readingfolder)))
			>&2 echo "Defaulting to creating a 'notes/' folder above $(pathto $readingfolder)"
			>&2 printf "  [Enter to confirm, or space to manually select its parent directory] "
			read -d'' -s -n1 -r
			if [ "$REPLY" = ' ' ]; then
				notes_parent_dir=$(zenity --file-selection --directory)
				mkdir $notes_parent_dir'/notes/'
			fi
		fi
	done
	# The following is reached when the current directory is 'readings':
	cd .. # './readings/' is now underneath the working directory, as should be './notes/'
	if [ ! -z $notes_parent_dir ]
	then notes_dir=$notes_parent_dir'/notes/'
	else notes_dir=$(readlink -f ./)"/notes/"
	fi
	if [ ! -d $notes_dir ]; then
		>&2 echo "Warning: unable to find a 'notes' folder alongside the 'readings' folder."
		>&2 echo "Creating new directory: $notes_dir"
		>&2 printf "  [Enter to confirm, or space to manually select the directory to create a 'notes/' folder in] "
		read -d'' -s -n1 -r
		if [ "$REPLY" = ' ' ]; then
			notes_parent_dir=$(zenity --file-selection --directory)
			notes_dir=$notes_parent_dir'/notes/'
		fi
		mkdir $notes_dir
	fi
	cd $notes_dir
	readingnotefile=$notes_dir$file_auth_prefix'.md'
	
	# Check if this note file exists:
	#   If not,
	#     $2 parameter --override-notefilecheck to be used when downloading a file and making notes concurrently
	#     ask: create it?
	
	if [ -z $readingnotefile ] && [ "$2" != '--skip-create-check' ]; then
		>&2 printf "No note file found - do you want to create it? [Enter to confirm, or space to abort] "
		read -d'' -s -n1 -r
		if [ "$REPLY" != ' ' ]; then
			>&2 echo "Exitting without creating a note file..."
			cd $FN_STARTDIR
			return 10
		else
			touch $readingnotefile
			echo -e "\n\n\n" >> $readingnotefile
			>&2 echo "Created a new note file: $(pathto $readingnotefile)"
		fi
	elif [ -z $readingnotefile ]; then
		# The `--skip-create-check` flag is on, so create the new file
		touch $readingnotefile
		echo -e "\n\n\n" >> $readingnotefile
		>&2 echo "Created a new note file: $(pathto $readingnotefile)"
	fi
	# Finally, return the path to the note file (through STDOUT)
	echo $readingnotefile
	cd $FN_STARTDIR
	return 0
}

# First argument is the PDF file in a `readings/` folder with a corresponding `notes/` folder
#   - further arguments as per `findnote` usage guide
function takenote () {
	notefile=$(findnote "$@")
	atom "$notefile"
}

# As above, but don't edit it, just touch and go
function makenote () {
	notefile=$(findnote "$@")
	touch "$notefile"
}

# Pass in a filename as $1
function pdfread() {
	# will timeout after 50 * 0.1s = 5 seconds
	local loops=0
	xdg-open "$@" 2>/dev/null
	# don't think dimensions are right, but just to push it to the other screen and maximise
	# if xdotool search --name "$@" windowactivate; then return 0; fi
	until wmctrl -r "$@" -e 0,1280,0,1280,1024 -b add,maximized_vert,maximized_horz; do
		if [ $loops -eq 50 ]; then return 1; fi
		sleep 0.1
		((loops++))
	done
}

# Take notes and view a PDF
# NB: can specify `--skip-create-check` (e.g. as used in `paperdl()`)
function readnwrite () {
	xdg-open "$1" 2>/dev/null &	
	takenote "$@"
}
